# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this library; if not, see <http://www.gnu.org/licenses/>.

"""
preoccupied.pydantic.selector.discriminator
Dynamic discriminator helpers and registration-aware base model primitives.

:author: Christopher O'Brien <obriencj@preoccupied.net>
:license: GNU General Public License v3
:ai-assistant: GPT-5 Codex via Cursor
"""


from typing import Any, Dict, Optional, Tuple, Type

from pydantic import BaseModel

from .registry import MatchRegistry, SelectorRegistry


__all__ = (
    "SelectorMeta",
    "MatchSelector",
)


class SelectorMeta(type(BaseModel)):
    """
    Metaclass responsible for discriminator-aware model registration.
    """

    def __call__(cls, *args: Any, **kwargs: Any) -> Type[BaseModel]:
        """
        Route façade instantiation through validation to return concrete subclasses.
        """

        facade = getattr(cls, "__selector_facade__", cls)
        if facade is cls:
            # we're overriding initialization and relying on model_validate to
            # be the one that will pick the appropriate subclass, so we need to
            # do some of the translation from __init__ to model_validate that would
            # normally be taken care of by pydantic itself.

            if args and kwargs:
                raise TypeError(
                    "Mixing positional and keyword arguments is not"
                    " supported for façades.")
            if kwargs:
                payload: Any = dict(kwargs)
            elif len(args) == 1:
                payload = args[0]
            elif not args:
                payload = {}
            else:
                raise TypeError(
                    "Unexpected positional arguments for façade"
                    " instantiation.")

            return cls.model_validate(payload)
        return super().__call__(*args, **kwargs)


    def __new__(  # type: ignore[override]
            mcls,
            name: str,
            bases: Tuple[type, ...],
            namespace: Dict[str, Any],
            **kwargs: Any) -> Type[BaseModel]:

        model_cls = super().__new__(mcls, name, bases, namespace, **kwargs)

        if model_cls.__dict__.get("__selector_registry_cls__", None) is not None:
            # This is a new selector base class, so we'll just set that up.
            mcls._initialize_base(model_cls)

        else:
            facade = getattr(model_cls, "__selector_facade__", None)
            if facade is None:
                # treat this as a new façade.
                mcls._initialize_base(model_cls)
                mcls._configure_facade(model_cls)

            else:
                # this is a concrete subclass of an existing façade.
                mcls._register_subclass(facade, model_cls)

        # we wedge our own impl of model_validate into the class if
        # one isn't provided.
        if "model_validate" not in model_cls.__dict__:
            setattr(
                model_cls,
                "model_validate",
                classmethod(_model_validate_helper)
            )

        return model_cls


    @classmethod
    def _initialize_base(cls, model_cls: Type[BaseModel]) -> None:
        """
        Seed metadata for the base generated by the factory. The base is
        what defines the behavior of later facades that inherit from it.
        """

        if not hasattr(model_cls, "__selector_registry_cls__"):
            model_cls.__selector_registry_cls__ = MatchRegistry


    @classmethod
    def _configure_facade(cls, model_cls: Type[BaseModel]) -> None:
        """
        Initialize a façade capable of routing to registered subclasses.
        """

        registry_cls: Type[SelectorRegistry] = getattr(
            model_cls, "__selector_registry_cls__", None)

        # we set that value during _initialize_base, so it had damned
        # well better be present.
        assert registry_cls is not None

        model_cls.__selector_facade__ = model_cls
        model_cls.__selector_registry__ = registry_cls(model_cls)


    @classmethod
    def _register_subclass(
            cls,
            facade: Type[BaseModel],
            model_cls: Type[BaseModel]) -> None:
        """
        Register a subclass beneath the identified root façade.
        """

        registry: SelectorRegistry = getattr(facade, "__selector_registry__", None)
        assert registry is not None

        registry.register(model_cls)

        # we'll just inherit these values from the facade
        # model_cls.__selector_facade__ = facade
        # model_cls.__selector_registry__ = registry


def _model_validate_helper(
        cls: Type[BaseModel],
        obj: Any,
        *,
        strict: Optional[bool] = None,
        from_attributes: Optional[bool] = None,
        context: Optional[Dict[str, Any]] = None) -> Type[BaseModel]:
    """
    Perform dynamic validation, dispatching façade classes to registered
    subclasses.
    """

    if cls is getattr(cls, "__selector_root__", cls):
        registry: Optional[SelectorRegistry] = getattr(cls, "__selector_registry__", None)
        if registry is None:
            registry_cls: Type[SelectorRegistry] = getattr(
                cls,
                "__selector_registry_cls__",
                MatchRegistry,
            )
            registry = registry_cls(cls)
            cls.__selector_registry__ = registry

        obj = registry.normalize(obj)
        subclass = registry.resolve(obj)

        if subclass is not cls:
            # we might allow registry to resolve to the facade itself.
            return subclass.model_validate(
                obj,
                strict=strict,
                from_attributes=from_attributes,
                context=context)
        # fallthru

    return BaseModel.model_validate.__func__(
        cls,
        obj,
        strict=strict,
        from_attributes=from_attributes,
        context=context)


class MatchSelector(BaseModel, metaclass=SelectorMeta):
    """
    Base model class for selector façades.

    Façades must declare a single discriminator field using the `Discriminator`
    helper.

    Instantiation or `model_validate(...)` will select the appropriate subclass
    based on the value of the discriminator field on the incoming data, compared
    against the values of the field on the registered subclasses.
    """

    # strictly speaking this isn't necessary to declare here, since
    # MatchRegistry is the default, but someone might read this one day
    # wondering how to override their registry class. You do it like this.
    __selector_registry_cls__ = MatchRegistry


# The end.
