# This library is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This library is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this library; if not, see <http://www.gnu.org/licenses/>.

"""
preoccupied.pydantic.selector.discriminator
Dynamic discriminator helpers and registration-aware base model primitives.

:author: Christopher O'Brien <obriencj@preoccupied.net>
:license: GNU General Public License v3
:ai-assistant: GPT-5 Codex via Cursor
"""


from typing import Any, Callable, Dict, Mapping, Optional, Tuple, Type

from pydantic import BaseModel

from .registry import MatchRegistry, SelectorRegistry


__all__ = (
    "SelectorMeta",
    "MatchSelector",
)


class SelectorMeta(type(BaseModel)):
    """
    Metaclass responsible for discriminator-aware model registration.
    """

    def __call__(cls, *args: Any, **kwargs: Any) -> Type[BaseModel]:
        """
        Route façade instantiation through validation to return concrete subclasses.
        """

        root = getattr(cls, "__selector_root__", cls)
        if root is cls:
            # we're overriding initialization and relying on model_validate to
            # be the one that will pick the appropriate subclass, so we need to
            # do some of the translation from __init__ to model_validate that would
            # normally be taken care of by pydantic itself.

            if args and kwargs:
                raise TypeError(
                    "Mixing positional and keyword arguments is not"
                    " supported for façades.")
            if kwargs:
                payload: Any = dict(kwargs)
            elif len(args) == 1:
                payload = args[0]
            elif not args:
                payload = {}
            else:
                raise TypeError(
                    "Unexpected positional arguments for façade"
                    " instantiation.")

            return cls.model_validate(payload)
        return super().__call__(*args, **kwargs)


    def __new__(  # type: ignore[override]
            mcls,
            name: str,
            bases: Tuple[type, ...],
            namespace: Dict[str, Any],
            **kwargs: Any) -> Type[BaseModel]:

        model_cls = super().__new__(mcls, name, bases, namespace, **kwargs)

        if model_cls.__dict__.get("__selector_registry_cls__", None) is not None:
            # This is a new selector base class, so we'll just set that up.
            mcls._initialize_base(model_cls)
            mcls._attach_interface(model_cls)

        else:
            root = mcls._locate_root(bases=model_cls.__mro__[1:])
            if root is None:
                # No selector-aware parent; treat this as a new façade.
                mcls._initialize_base(model_cls)
                mcls._attach_interface(model_cls)
                mcls._configure_root(model_cls)

            else:
                # this is a concrete subclass
                mcls._register_subclass(root, model_cls)
                mcls._attach_interface(model_cls)

        return model_cls


    @staticmethod
    def _locate_root(
            bases: Tuple[Type[Any], ...]) -> Optional[Type[BaseModel]]:
        """
        Find the nearest selector-aware ancestor in the provided MRO slice.
        """

        for base in bases:
            if isinstance(base, SelectorMeta):
                registry = getattr(base, "__selector_registry__", None)
                if registry is None:
                    continue
                return base
        return None


    @classmethod
    def _initialize_base(cls, model_cls: Type[BaseModel]) -> None:
        """
        Seed metadata for the rootless base generated by the factory.
        """

        if not hasattr(model_cls, "__selector_registry_cls__"):
            model_cls.__selector_registry_cls__ = MatchRegistry

        model_cls.__selector_root__ = None
        model_cls.__selector_registry__ = None


    @classmethod
    def _configure_root(cls, model_cls: Type[BaseModel]) -> None:
        """
        Initialize a root façade capable of routing to registered subclasses.
        """

        registry_cls: Type[SelectorRegistry] = getattr(
            model_cls,
            "__selector_registry_cls__",
            MatchRegistry,
        )
        registry = registry_cls(model_cls)

        model_cls.__selector_root__ = model_cls
        model_cls.__selector_registry_cls__ = registry_cls
        model_cls.__selector_registry__ = registry


    @classmethod
    def _register_subclass(
            cls,
            root: Type[BaseModel],
            model_cls: Type[BaseModel]) -> None:
        """
        Register a subclass beneath the identified root façade.
        """

        registry: Optional[SelectorRegistry] = getattr(root, "__selector_registry__", None)
        if registry is None:
            registry_cls: Type[SelectorRegistry] = getattr(
                root,
                "__selector_registry_cls__",
                MatchRegistry,
            )
            registry = registry_cls(root)
            root.__selector_registry__ = registry

        registry.register(model_cls)
        model_cls.__selector_root__ = root
        model_cls.__selector_registry_cls__ = getattr(
            root,
            "__selector_registry_cls__",
            MatchRegistry,
        )
        model_cls.__selector_registry__ = None


    @classmethod
    def _attach_interface(cls, model_cls: Type[BaseModel]) -> None:
        """
        Ensure discriminator helper methods and defaults are present on the class.
        """

        interface_methods = {
            "model_validate": classmethod(_model_validate_helper),
        }

        for name, method in interface_methods.items():
            if name not in model_cls.__dict__:
                setattr(model_cls, name, method)


def _model_validate_helper(
        cls: Type[BaseModel],
        obj: Any,
        *,
        strict: Optional[bool] = None,
        from_attributes: Optional[bool] = None,
        context: Optional[Dict[str, Any]] = None) -> Type[BaseModel]:
    """
    Perform dynamic validation, dispatching façade classes to registered subclasses.
    """

    if cls is getattr(cls, "__selector_root__", cls):
        registry: Optional[SelectorRegistry] = getattr(cls, "__selector_registry__", None)
        if registry is None:
            registry_cls: Type[SelectorRegistry] = getattr(
                cls,
                "__selector_registry_cls__",
                MatchRegistry,
            )
            registry = registry_cls(cls)
            cls.__selector_registry__ = registry

        obj = registry.normalize(obj)
        subclass = registry.resolve(obj)

        if subclass is not cls:
            # we might allow registry to resolve to the facade itself.
            return subclass.model_validate(
                obj,
                strict=strict,
                from_attributes=from_attributes,
                context=context)
        # fallthru

    return BaseModel.model_validate.__func__(
        cls,
        obj,
        strict=strict,
        from_attributes=from_attributes,
        context=context)


class MatchSelector(BaseModel, metaclass=SelectorMeta):
    """
    Base model that acts as a facade for to its subclasses, based on the value
    of a discriminator field.

    Subclasses must declare a single discriminator field using the
    `Discriminator` helper.

    instantiation or model_validate() will select the appropriate subclass based
    on the value of the discriminator field on the incoming data, compared
    against the values of the field on the registered subclasses.
    """

    __selector_registry_cls__ = MatchRegistry


# The end.
